height_m = height / 100,
BMI = mass / (height_m^2)
) %>%
select(BMI, everything()) %>%
slice_max(., order_by = BMI, n = 3)
starwars %>%
select(name, species)
## TEMA 5 ##
# Vectores ----------------------------------------------------------------
# * Vectores atómicos -----------------------------------------------------
x <- c(1, FALSE)
typeof(x)
#Comentarios
# EJecutar código: Botón Run o Ctrl+Enter
# shift+ctl+r -------------------------------------------------------------
# Así es como se crean secciones
# * Subsección -------------------------------------------------------------
# ** Subsubsección --------------------------------------------------------
# Vamos poniendo al nombre unos * delante para hacer una sección
# dentro de otra.
# Crear un objeto (Atajo de teclado: 'Alt' + '-')
x <- 3
xx <- 4
# Imprimir (en consola) un objeto
?print(x) # Para pedir ayuda sobre una función seleccionarla y pulsar f1
# O bien usar '?' delante de la función correspondiente y ejecutar solo ese cachito
x
xx
class(x)
typeof(x)
#Vector numérico entero
y <- 3L
class(y)
typeof(y)
# Vector operación matemática
z <- 1L + 1L
z
class(z)
typeof(z)
# Tipos de vectores
lgl_var <- c(TRUE, FALSE) #Lógicos
int_var <- c(1L, 6L, 10L) #
dbl_var <- c(1, 2.5, 4.5)
chr_var <- c("these are", "some strings")
typeof(chr_var)
# ** Valores Ausentes -----------------------------------------------------
x <- c(1,5,8,10)
mean(x) #Media aritmética
x <- c(1,5, NA,10)
mean(x, na.rm = TRUE) #Va a saltarse ese valor NA y va a ejecutar la media robusta
#na.rm sirve para indicar si el valor NA se desprecia o no en el
#proceso de compilación
is.na(x) # Vamos comprobando qué elementos del vector
#son nulos y cuales no.
# ** Coacción (Coercion) --------------------------------------------------
# Regla para coercion: character > double > integer > logical →
#Si mezclamos un valor tipo character con uno double, tiene preferencia
#el tipo character, entonces el objeto entero es de tipo character.
c(1,2,3)
typeof(c(1,2,3))
#No podemos mezclar distintos tipos de elementos dentro de un mismo vector.
#No estamos modificando el entorno porque no hemos asignado una variable/objeto
#a estos valores.
c(1,2,'Pablo')
#Pablo sin comillas: Busca el nombre asignado a un objeto Pablo,
#no vemos ningún Pablo en la tabla de valores.
typeof(c(1,2,'Pablo'))
class(c(1,2,'Pablo'))
c(TRUE,FALSE,FALSE, 1L, 2, "Tubby")
typeof(c(TRUE,FALSE,FALSE, 1L, 2, "Tubby"))
#Comprobación de la regla de coacción, ir probando con modificaciones
# Regla de coercion --> útil
x <- c(FALSE, FALSE, TRUE)
x
is.logical(x)
as.numeric(x) #Crea o coerciona objetos al tipo que le estemos pidiendo
#Esto solo es una consulta en la consola, no se modifica el objeto.
#Para modificar el objeto, creamos una nueva asignación a 'x'
x <- as.numeric(x)
is.logical(x)
#Funciones matemáticas también siguen la "coercion"
sum(x)
mean(x)
# Forzar con as. a un cáracter
c(1, 1.5, "a")
as.numeric(c(1, 1.5, "a")) #Nos va a dar error, un character no se puede
#coeccionar a un numeric
prueba <- c(1L, 2L, 3L)
typeof(prueba)
class(prueba)
# ** Nombres -----------------------------------------------------------------
# Primera aproximación a entrega de nombres (de elementos)
#Podemos indexar a los objetos por sus nombres. ¿Indexar que significa?
# = Registrar, Referenciar...
x <- c(a = 1, b = 2, c = 3)
x
class(x)
typeof(x)
names(x)
attributes(x)
# Segunda aproximación a entrega de nombres (de elementos)
x <- c(1:3)
x
names(x) <- c("a", "b", "c")
names(x)
# Tercera aproximación a entrega de nombres (de elementos)
#No lo vamos a ver en profundidad.
x <- setNames(1:3, c("h", "j", "k")) #Permite crear obj, a la vez que nombres
names(x)
x
# Para quitar los nombres usamos unname()
x <- unname(x)
x
# ** Dimensiones de vector y de matrices ----------------------------------------------------------
dim(x) #La dimensión de un vector es nula
length(x)
x <- matrix(1:6 , nrow = 3, ncol = 3) #Matriz de 3filas y 3columnas
#Valores a introducir en la matríz, del 1 al 6, la longitud difiere con
#el tamaño de la matriz.
x
dim(x) #Dimensión = Filas , Columnas
# ** Indexación Vectores: con corchetes --------------------------------------------------
A <- c("a", "b", "c", "d", "e", "f", "g", "h")
A
# Elementos dentro del vector A
A[3] #No se indexa partiendo de la posición 0 como en Python
A[5:7]
# Rango
A[1:3]
# Último elemento
length(A)
A[7]
A[length(A)] # = A[8]
A[9]
A[1:3]
typeof(A[1:3])
# ** Factores -------------------------------------------------------------
x <- factor(c("a", "b", "b", "a"))
x
typeof(x)
attributes(x)
# Ejemplo #2 de factores
sex_char <- c("m", "m", "m")
sex_char
typeof(sex_char)
table(sex_char)
sex_factor <- factor(sex_char, levels = c("m", "f"), labels = c("Macho", "Hembra"))
sex_factor
attributes(sex_factor)
table(c("m", "m", "m"))
table(sex_factor)#Vemos que sí que está el grupo hembra, a pesar de estar vacío,
# ** Factores ordinales ---------------------------------------------------
grade <- ordered(c("b", "b", "a", "c"), levels = c("c", "b", "a"))
grade
# * Fechas ----------------------------------------------------------------
# Los vectores de fecha se construyen sobre los vectores dobles
today <- Sys.Date()
today
class(today)
typeof(today) #Laclase fecha se guarda como un número doble
attributes(today)
# Fechas desde caracter
c("1970-02-01")
class(c("1970-02-01"))
Newdate <- as.Date(c("1970/02/01"))
Newdate
class(Newdate)
unclass(Newdate)
# * Fechas-Horas ----------------------------------------------------------
# Base R proporciona dos formas de almacenar información de fecha y hora, POSIXct y POSIXlt.
now_ct <- as.POSIXct("2018-08-01 22:00", tz = "UTC")
now_ct
typeof(now_ct)
attributes(now_ct)
#tzone, permite cambiar la zona horaria muy fácilmente
structure(now_ct)
structure(now_ct, tzone = "Asia/Tokyo") #time zone
structure(now_ct, tzone = "Australia/Lord_Howe")
# * Duraciones ------------------------------------------------------------
# Representan la cantidad de tiempo entre pares de fechas o fechas-horas.
# Se almacenan en `difftimes`
one_week_1 <- as.difftime(1, units = "weeks")
one_week_1
typeof(one_week_1)
attributes(one_week_1)
one_week_2 <- as.difftime(7, units = "days")
one_week_2
typeof(one_week_2)
attributes(one_week_2)
difftime(structure(now_ct), structure(now_ct), units = "week")
difftime(structure(now_ct), structure(Sys.Date()), units = "hours")
# Matrices/Arrays ---------------------------------------------------------
# Matrices guardan la información en 2 dimensiones
# Arrays guardan la información en 2 o más dimensiones
m <- matrix(seq(1:6), nrow = 2)
m <- matrix(seq(1:6), nrow = 2, byrow = TRUE)
m
str(m)
typeof(m)
class(m)
# * Coercion --------------------------------------------------------------
m
m1 <- matrix(c(1, 2, 3, 4, 5, "Pablo"), nrow = 2)
m1
str(m1)
typeof(m1)
# ** Indexación de Matrices -----------------------------------------------
# Al haber dos dimensiones, la indexación respeta estas dimensiones
# Siempre: "filas, columnas"
m2 <- matrix(seq(1:8), nrow = 4, byrow = TRUE)
m2
# Indexación por posición
dim(m2)
# Indexación de la segunda fila (fila = 2, columnas = todas)
m2[2,]
# Indexación de la segunda columna (fila = todas, columnas = 2)
m2[,2]
# Indexación por nombres
colnames(m2)
colnames(m2) <- c("Impares", "Pares")
colnames(m2)
m2
# Primera columna
m2[,"Impares"]
# Segunda columna
m2[1:3,"Pares"]
m2[c(1,3),"Pares"]
# indexacion matrices, sí cambia la clase a diferencia que pasa con los vectores
class(m2)
str(m2[1:3,"Pares"])
class(m2[1:3,"Pares"]) #Clase de un trozo de la matríz --> Es un vector
# Tabla de datos (Dataframe) ----------------------------------------------
# Probablemente el formato más usado.
#Análogo heterogéneo de las matrices.
df1 <- data.frame(
Numeros = 1:5,
Letras = letters[1:5])
df1
typeof(df1)
attributes(df1)
# Carga de paquete y uso de tibble
library(dplyr)
#Dataframe, enchular, no entiendo esto.
df2 <- tibble(
Numeros = 1:5,
Letras = letters[1:5])
df2
typeof(df2)
str(df2$Nu) #"Le pedimos la estructura del dataframe del atributo Nu"
# ** Concatenación/Combinación de dataframes -------------------------------
# Ciclado en dataframes
data.frame(x = 1:4, y = 'Spain')
# *** Tibble v/s Dataframe ------------------------------------------------
#data.frame
data.frame(
x = 1:3,
y = x * 2 #Los obj no deben depender entre ellos en su formulación.
# Dataframe no reconoce que la x es la misma que la de la siguiente fila
)
data(starwars)
starwars
starwars %>%
group_by(species) %>%
filter(n() > 1) %>%
summarise(across(c(height, mass, birth_year), ~ mean(.x, na.rm = TRUE)))
# Repetir la misma operación por columnas
library(tidyverse)
starwars %>%
group_by(species) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
?starwars
install.packages("tidyverse")
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year))
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na()
library(tydyr)
library(tidyr)
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na()
# Pivot_longer (transformar desde ancho a largo)
Wide_Starwars
pivot_longer(data = Wide_Starwars, names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
Wide_Starwars <-
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na()
Wide_Starwars
# Pivot_longer (transformar desde ancho a largo)
Wide_Starwars
pivot_longer(data = Wide_Starwars, names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
# Pipeline #1
Wide_Starwars %>%
pivot_longer(data = ., names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
# Pipeline #2
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na() %>%
pivot_longer(data = ., names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
# Guardamos un objeto para siguiente sección
Long_Starwars <-
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na() %>%
pivot_longer(data = ., names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
Long_Starwars
# Pivot_wider (desde largo a ancho, es algo más sencillo)
Long_Starwars
pivot_wider(data = Long_Starwars, names_from = "Variable", values_from = "Valores")
# Pipeline #1
Long_Starwars %>%
pivot_wider(data = ., names_from = "Variable", values_from = "Valores")
# Tambien funciona
Long_Starwars %>%
pivot_wider(data = ., names_from = Variable, values_from = Valores)
Long_Starwars %>%
pivot_wider(data = ., names_from = Variable, values_from = Valores
# Pivot_longer (transformar desde ancho a largo)
Wide_Starwars
pivot_longer(data = Wide_Starwars, names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
# Pipeline #1
Wide_Starwars %>%
pivot_longer(data = ., names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
# Pipeline #2
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na() %>%
pivot_longer(data = ., names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
# Guardamos un objeto para siguiente sección
Long_Starwars <-
starwars %>%
group_by(homeworld) %>%
filter(n() > 1) %>%
summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>%
arrange(desc(birth_year)) %>%
drop_na() %>%
pivot_longer(data = ., names_to = "Variable", values_to = "Valores", cols = c(height:birth_year))
Long_Starwars
# Pivot_wider (desde largo a ancho, es algo más sencillo)
Long_Starwars
pivot_wider(data = Long_Starwars, names_from = "Variable", values_from = "Valores")
# Pipeline #1
Long_Starwars %>%
pivot_wider(data = ., names_from = "Variable", values_from = "Valores")
# Tambien funciona sin comillas en los atributos
Long_Starwars %>%
pivot_wider(data = ., names_from = Variable, values_from = Valores)
# *** Carga de datos ------------------------------------------------------
# Loading the "Galapagos_summary.csv" file
Mean_Galapagos <- read_csv(file = "INPUT/DATA/Galapagos_summary.csv",
col_types = cols(
Island = readr::col_factor(levels = NULL),
Station = readr::col_factor(levels = NULL),
distance = readr::col_factor(levels = NULL),
Av_Temp = col_double(),
Av_Salinity = col_double(),
Av_Chla = col_double()
))
Mean_Galapagos
# ** Verbos de dos tablas -------------------------------------------------
library(readr)
# *** Carga de datos ------------------------------------------------------
# Loading the "Galapagos_summary.csv" file
Mean_Galapagos <- read_csv(file = "INPUT/DATA/Galapagos_summary.csv",
col_types = cols(
Island = readr::col_factor(levels = NULL),
Station = readr::col_factor(levels = NULL),
distance = readr::col_factor(levels = NULL),
Av_Temp = col_double(),
Av_Salinity = col_double(),
Av_Chla = col_double()
))
Mean_Galapagos
Long_Starwars %>%
pivot_wider(data = ., names_from = Variable, values_from = Valores)
# *** Carga de datos ------------------------------------------------------
# Loading the "Galapagos_summary.csv" file
Mean_Galapagos <- read_csv(file = "INPUT/DATA/Galapagos_summary.csv",
col_types = cols(
Island = readr::col_factor(levels = NULL),
Station = readr::col_factor(levels = NULL),
distance = readr::col_factor(levels = NULL),
Av_Temp = col_double(),
Av_Salinity = col_double(),
Av_Chla = col_double()
))
Acc_Car <- read_delim("INPUT/DATA/accidentalidad-por-carreteras.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
knitr::opts_chunk$set(echo = TRUE)
```{r pressure, echo=FALSE}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
Ancho_Car <- read_delim("INPUT/DATA/anchura-de-carreteras.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
x <- c(1,2,3,4,5,6)
y <- c(10,20,30)
x + y
_vector <- c(TRUE, TRUE, FALSE, 1)
library(readr)
Muertes_menores_en_una_semana_por_comunidad_autónoma <- read_delim("Trabajo_DAG/Input/data/02022.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
View(Muertes_menores_en_una_semana_por_comunidad_autónoma)
library(readxl)
ENS_2017 <- read_excel("Trabajo_DAG/Input/data/ENSE17_MOD3_REL (1).xlsx")
View(ENS_2017)
#Importación de los datos
# *
library(readr)
Muerte_niños_semana <- read_delim("Trabajo_DAG/Input/data/02022.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
View(Muerte_niños_semana)
# *
library(readxl)
ENS_2017 <- read_excel("Trabajo_DAG/Input/data/ENSE17_MOD3_REL (1).xlsx")
View(ENS_2017)
save.image("C:/ESTUDIOS/Uni/Curso 2022_2023/Fuentes datos biomédicas y web semánticas/Seminario_Fuentes/Trabajo_DAG/Memory.RData")
#Importación de los datos
# *
library(readr)
Muerte_niños_semana <- read_delim("Trabajo_DAG/Input/data/02022.csv",
delim = ";", escape_double = FALSE, trim_ws = TRUE)
View(Muerte_niños_semana)
# *
library(readxl)
ENS_2017 <- read_excel("Trabajo_DAG/Input/data/ENSE17_MOD3_REL (1).xlsx")
View(ENS_2017)
save.image("C:/ESTUDIOS/Uni/Curso 2022_2023/Fuentes datos biomédicas y web semánticas/Seminario_Fuentes/Trabajo_DAG/Memory.RData")
library(tidyverse)
?ggplot2
# Cargamos los datos
data("mpg")
# reseña del set de datos
?mpg
str(mpg)
?ggplot
ggplot(data = mpg, aes(x = displ, y = hwy))
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point()
ggplot(data = mpg, aes(x = displ, y = hwy))
# Controlando el color -- Fijo
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point(colour = "darkgreen")
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point(aes(colour = factor(cyl)))
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point(colour = "palevioletred2")
data("mpg")
str(mpg)
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point(aes(colour = cyl))
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point() +
geom_smooth()
# Podemos comparar diferentes modelos de ajustes
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point() + #Añadimos puntos y luego añadimos "líneas" por así decirlo
geom_smooth(method = "loess", colour = "blue") + #Este modelo no lo conocemos
geom_smooth(method = "lm", colour = "red") #Modelo lineal
# Podemos ajustar modelos dependientes de cada nivel de la variable categórica
ggplot(data = mpg, aes(x = displ, y = hwy)) +
geom_point(aes(colour = factor(cyl))) +
geom_smooth(method = "lm", aes(colour = factor(cyl))) #Aplicamos una regresión para
#cada nivel del factor con un color para cada una.
data("diamonds")
data("diamonds")
str(diamonds)
?diamonds
ggplot(data = diamonds, aes(x = cut)) +
geom_bar()
diamonds
mpg
#Tmb podemos verlo así:
mpg
ggplot(data = diamonds, aes(x = cut)) +
geom_bar(aes(colour = clarity))
diamonds
# Modificando el "relleno" de las cajas
ggplot(data = diamonds, aes(x = cut)) +
geom_bar(aes(fill = clarity), colour ="black") #Con "fill"
#Color del borde negro
# Para hacer comparaciones "intra-clase" de la variable de relleno
ggplot(data = diamonds, aes(x = cut)) +
geom_bar(aes(fill = clarity), position = "fill")
# Para hacer comparaciones entre niveles del eje X considerando la tercera variable
ggplot(data = diamonds, aes(x = cut)) +
geom_bar(aes(fill = clarity), position = "dodge")
?cut
